=========================================
Programming by functionality using events
=========================================

--------
Preamble
--------

The core idea:

   * One file per functionality so adding or removing a functionality
     only change one file.

   * Functionalities communicate using events.

   * When an event is launched it is dispatched to all the handlers
     of this event type.

   * The handler has a state parameter.
     This state can be used and modified.

   * Functionalities add their handlers to event types.

   * Functionalities send events. They can define the initial state.

   * Sending an event returns the return value of the last called handler.

   * Each handler has a priority, they are called in the order.
    
   * If an handler does not returns None then the other handlers
     will not be called and the value will be returned to
     the event sender.

   * The information flow can be of any kind when an event is sent:

       * From the sender to receivers.
       * From the receivers to the sender.
       * From a receiver to later called one.
       * A receiver can modify the information defined by a previous one.

-------------
Documentation
-------------

To launch demo: ./main.py

Only one import needed :

    from reactor import R

The main program defines the application full state as a global variable
usable by any functionality.
Concurrent modification of R.M is not thread safe: so protect it.

    class MyModel:
        my_data = 2024
    R.M = MyModel()

Sending an event :

    answer = R('event-type', attr1=value, attr2=value...)
    # 'answer' is None if no event handler managed the event
    #          or the data returned by the last event handler called

Add a new event receiver, functions are called by priorities (Abricot before Zombi).
The state is created clean from the attributes values defined when calling
and the handlers may change the attribute values or add new ones.
The caller can define any attributes, they are not checked.

    @R.handler('event-type','OPTIONAL_PRIORIY_AS_A_STRING')
    def function_name(state):
        """
        state.event contains the event type
        Other state attributes depends on the event type.
        """
        return "Any data to stop event processing"
        return None # To let over handlers analyse the event

Add a description to the event type:

    R.description('PRESTART', "No arguments, launched first")

Event types are not defined, their usage define their attributes.
Theses are some of the event type defined in the example application:

    R('PRESTART')             # Initialisation of the functionalities
    R('START')                # Start the functionalities
    R('RELOAD')               # Some Python modules have been reload
    R('print', string=, wfile=)
    R('eval', command=, wfile=, server=) # file and server are needed for live log
    R('translations', translations=)
    R('help', help=)
    R('get', server=)         # request analyser (in order to be stackable)
    R('http', server=)        # send HTTP header if not default
    R('buttons', buttons=)    # append tuple ('url', 'label') to add HTML buttons
    R('timer')                # Event send every 10 seconds

To see the full list, use «pr» on command line.

To add a new button for a new functionality on the home page or command line,
do not modify handle_home.py but create handle_xxx.py

    @R.handler('eval')
    def do_XXX(state):
        """If XXX command: do it"""
        if state.command != 'XXX':
            return None
        # Do XXX

    @R.handler('buttons', 'W') # W to be before Reload (Z)
    def xxx(state):
        """Add XXX button on home page"""
        state.buttons.append(('/XXX', '[[[XXX_button]]]'))

    @R.handler('help', 'Z')
    def print_help(state):
        "help for command line"
        state.help.append('  XXX : [[[XXX_button]]]')

    @R.handler('translations')
    def translations(state):
        "Translations"
        state.translations['en']['XXX_button'] = "Functionality XXX"
        state.translations['fr']['XXX_button'] = "Fonctionalité XXX"
    